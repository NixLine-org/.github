#
# NixLine Promote to Stable (reusable)
#
# Promotes commits from baseline repositories to stable with comprehensive validation.
# Supports both stable (full audit trail with flake.lock updates) and unstable
# (lightweight tag-only) promotion modes.
#
# Features:
# - Validates commits before promotion (flake check, app verification)
# - Creates audit trail commits for stable promotions
# - Updates flake.lock files for consumers
# - Handles both PR-based and manual promotion workflows
# - Creates issues on validation failures with detailed reports
#
# Called by: baseline repository promotion workflows
# Purpose: Centralized, validated promotion logic across NixLine organization
#

name: NixLine Promote to Stable (reusable)

on:
  workflow_call:
    inputs:
      promotion_mode:
        description: 'Promotion mode: pr-based or manual'
        required: false
        type: string
        default: 'pr-based'
      commit_hash:
        description: 'Commit hash to promote (for manual mode, defaults to HEAD)'
        required: false
        type: string
      stable_tag:
        description: 'Target stable tag name'
        required: false
        type: string
        default: 'stable'
      promotion_target:
        description: 'Promotion target: stable (full audit trail) or unstable (lightweight)'
        required: false
        type: string
        default: 'stable'

# Note: This workflow requires the following permissions:
# permissions:
#   contents: write
#   actions: write
#   issues: write
#   pull-requests: write

jobs:
  promote:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Determine promotion commit
        id: candidate
        run: |
          if [ "${{ inputs.promotion_mode }}" == "manual" ]; then
            # Manual promotion - use provided commit or HEAD
            if [ -n "${{ inputs.commit_hash }}" ]; then
              CANDIDATE_COMMIT="${{ inputs.commit_hash }}"
              echo "Using manual commit: $CANDIDATE_COMMIT"
            else
              CANDIDATE_COMMIT=$(git rev-parse HEAD)
              echo "Using HEAD of main: $CANDIDATE_COMMIT"
            fi
            echo "promotion_type=manual" >> $GITHUB_OUTPUT
          else
            # PR-based promotion - read from .stable-candidate
            if [ -f .stable-candidate ]; then
              CANDIDATE_COMMIT=$(cat .stable-candidate)
              echo "Using PR promotion commit: $CANDIDATE_COMMIT"
              echo "promotion_type=pr" >> $GITHUB_OUTPUT
            else
              # First time setup - use current HEAD and initialize .stable-candidate
              CANDIDATE_COMMIT=$(git rev-parse HEAD)
              echo "No .stable-candidate found, initializing with current HEAD: $CANDIDATE_COMMIT"
              echo "$CANDIDATE_COMMIT" > .stable-candidate

              # Create initialization commit
              git add .stable-candidate
              git commit -m "Initialize stable candidate tracking

              This commit initializes the .stable-candidate file for the promotion workflow.
              The file tracks which commit should be promoted to stable."

              echo "promotion_type=initialization" >> $GITHUB_OUTPUT
            fi
          fi

          echo "commit_hash=$CANDIDATE_COMMIT" >> $GITHUB_OUTPUT
          SHORT_HASH="${CANDIDATE_COMMIT:0:12}"
          echo "short_hash=$SHORT_HASH" >> $GITHUB_OUTPUT
          echo "found=true" >> $GITHUB_OUTPUT

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes

      - name: Checkout promotion commit
        run: |
          git checkout ${{ steps.candidate.outputs.commit_hash }}

      - name: Validate flake
        id: validate
        run: |
          echo "## Validating Commit for Promotion" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ steps.candidate.outputs.commit_hash }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          VALIDATION_PASSED=true

          # Run flake check
          echo "### Flake Check" >> $GITHUB_STEP_SUMMARY
          if nix flake check --all-systems --no-build --show-trace; then
            echo "[PASS] Flake check passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "[FAIL] Flake check failed" >> $GITHUB_STEP_SUMMARY
            VALIDATION_PASSED=false
          fi

          # Verify critical apps exist
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### App Verification" >> $GITHUB_STEP_SUMMARY
          for app in sync check create-pack import-policy fetch-license list-licenses; do
            if nix flake show --json | jq -e ".apps.\"x86_64-linux\".\"$app\"" > /dev/null 2>&1; then
              echo "[PASS] **$app**: Available" >> $GITHUB_STEP_SUMMARY
            else
              echo "[FAIL] **$app**: Missing" >> $GITHUB_STEP_SUMMARY
              VALIDATION_PASSED=false
            fi
          done

          # Test key apps
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### App Testing" >> $GITHUB_STEP_SUMMARY

          # Test sync with dry-run (if available)
          if nix run .#sync -- --help > /dev/null 2>&1; then
            echo "[PASS] **sync**: Responsive" >> $GITHUB_STEP_SUMMARY
          else
            echo "[FAIL] **sync**: Not responsive" >> $GITHUB_STEP_SUMMARY
            VALIDATION_PASSED=false
          fi

          # Test list-licenses
          if nix run .#list-licenses > /dev/null 2>&1; then
            echo "[PASS] **list-licenses**: Working" >> $GITHUB_STEP_SUMMARY
          else
            echo "[FAIL] **list-licenses**: Failed" >> $GITHUB_STEP_SUMMARY
            VALIDATION_PASSED=false
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$VALIDATION_PASSED" = "true" ]; then
            echo "### [PASS] Validation Result: PASSED" >> $GITHUB_STEP_SUMMARY
            echo "Commit is ready for promotion to stable." >> $GITHUB_STEP_SUMMARY
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "### [FAIL] Validation Result: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Commit failed validation and cannot be promoted." >> $GITHUB_STEP_SUMMARY
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout current main for audit trail
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'true' && inputs.promotion_target == 'stable'
        run: |
          # Switch back to current main branch to create audit trail
          # This prevents race conditions when main has moved forward
          git checkout main
          git pull origin main

      - name: Update flake.lock and create audit trail
        id: audit
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'true' && inputs.promotion_target == 'stable'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          COMMIT=${{ steps.candidate.outputs.commit_hash }}
          SHORT_HASH=${{ steps.candidate.outputs.short_hash }}

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update flake.lock for consumers
          nix flake update

          # Update consumer template flake.lock if it exists
          if [[ -f "templates/consumer/flake.nix" ]]; then
            echo "Updating consumer template flake.lock"
            cd templates/consumer
            nix flake update
            cd ../..
          fi

          # Update .stable-candidate file with promoted commit
          echo "$COMMIT" > .stable-candidate

          # Create audit trail commit only if there are changes
          git add flake.lock .stable-candidate
          # Add consumer template flake.lock if it was updated
          if [[ -f "templates/consumer/flake.lock" ]]; then
            git add templates/consumer/flake.lock
          fi

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit - flake.lock and .stable-candidate are already up to date"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Mark $SHORT_HASH as ${{ inputs.promotion_target }} candidate

          Promoted commit: $COMMIT
          Promotion type: ${{ steps.candidate.outputs.promotion_type }}
          Promotion target: ${{ inputs.promotion_target }}
          Validation passed: ${{ steps.validate.outputs.validation_passed }}
          Updated flake.lock for consumers"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

          # Only create PR if there are changes to commit
          if [ "${{ steps.audit.outputs.has_changes }}" == "true" ]; then
            # Create branch for audit commit (to work with branch protection)
            BRANCH_NAME="stable-promotion-$(date +%s)"
            git checkout -b "$BRANCH_NAME"

            # Try to push the branch, handling potential conflicts
            if ! git push origin "$BRANCH_NAME"; then
              echo "Branch push failed, attempting to resolve conflicts"
              git checkout main
              git pull origin main --rebase

              # Re-apply our changes on top of latest main
              nix flake update
              if [[ -f "templates/consumer/flake.nix" ]]; then
                cd templates/consumer
                nix flake update
                cd ../..
              fi
              echo "$COMMIT" > .stable-candidate

              # Re-commit with latest changes
              git add flake.lock .stable-candidate
              if [[ -f "templates/consumer/flake.lock" ]]; then
                git add templates/consumer/flake.lock
              fi
              git commit --amend --no-edit

              # Recreate branch
              git branch -D "$BRANCH_NAME" || true
              git checkout -b "$BRANCH_NAME"
            fi

            git push origin "$BRANCH_NAME" --force-with-lease

            # Create PR for the audit commit
            gh pr create \
              --title "Promote $SHORT_HASH to ${{ inputs.promotion_target }}" \
              --body "Automated promotion of commit $COMMIT to ${{ inputs.promotion_target }}.

            **Promotion Details:**
            - Commit: $COMMIT
            - Type: ${{ steps.candidate.outputs.promotion_type }}
            - Target: ${{ inputs.promotion_target }}
            - Validation: ✅ Passed

            This PR updates flake.lock for consumers and creates the promotion audit trail." \
              --base main \
              --head "$BRANCH_NAME"

            # Auto-merge the PR with admin override
            PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number')
            gh pr merge "$PR_NUMBER" --admin --squash

            # Delete the branch after successful merge
            git push origin --delete "$BRANCH_NAME" || echo "Branch already deleted"

            echo "Created audit trail commit for $COMMIT with updated flake.lock and cleaned up branch"
          else
            echo "No audit trail commit needed - no changes to flake.lock or .stable-candidate"
          fi

      - name: Update promotion tag
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'true'
        run: |
          COMMIT=${{ steps.candidate.outputs.commit_hash }}
          TARGET_TAG="${{ inputs.promotion_target == 'stable' && inputs.stable_tag || inputs.promotion_target }}"

          # Delete local tag if it exists to avoid conflicts
          git tag -d "$TARGET_TAG" 2>/dev/null || true

          # Create new tag at validated commit
          git tag -a "$TARGET_TAG" -m "Promote to ${{ inputs.promotion_target }}: $COMMIT" $COMMIT

          # Force push the tag (safer than remote delete + create)
          git push --force origin "$TARGET_TAG"

          echo "Updated $TARGET_TAG tag to $COMMIT"

      # Note: Cleanup is handled by the audit trail step which updates .stable-candidate
      # and the branch cleanup is handled by the stable candidate update workflow
      # No additional cleanup needed here to avoid branch protection violations

      - name: Create validation failure issue
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'false'
        uses: actions/github-script@v7
        env:
          COMMIT_HASH: ${{ steps.candidate.outputs.commit_hash }}
          SHORT_HASH: ${{ steps.candidate.outputs.short_hash }}
          PROMOTION_TYPE: ${{ steps.candidate.outputs.promotion_type }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const commitHash = process.env.COMMIT_HASH;
            const shortHash = process.env.SHORT_HASH;
            const promotionType = process.env.PROMOTION_TYPE;
            const runUrl = process.env.RUN_URL;

            const title = `Promotion to stable failed for ${shortHash}`;
            const body = `## Promotion Validation Failed\n\n` +
              `The promotion validation failed for commit \`${commitHash}\`.\n\n` +
              `**Promotion type:** ${promotionType}\n` +
              `**Commit:** \`${commitHash}\`\n\n` +
              `### Next Steps\n\n` +
              `1. Review the workflow logs for specific validation errors\n` +
              `2. Fix any identified issues in the codebase\n` +
              `3. Re-run promotion after fixes are committed\n\n` +
              `**Workflow run:** ${runUrl}\n\n` +
              `---\n\n` +
              `*This issue was automatically created by the promotion workflow.*`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['automated', 'promotion-failure', 'validation-error']
            });

      - name: Summary
        if: steps.candidate.outputs.found == 'true'
        run: |
          if [ "${{ steps.validate.outputs.validation_passed }}" == "true" ]; then
            echo "## Promotion Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "${{ steps.candidate.outputs.promotion_type }}" == "manual" ]; then
              echo "**Type:** Manual promotion" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Type:** PR-based promotion" >> $GITHUB_STEP_SUMMARY
            fi

            TARGET_TAG="${{ inputs.promotion_target == 'stable' && inputs.stable_tag || inputs.promotion_target }}"
            echo "**$TARGET_TAG tag updated to:** \`${{ steps.candidate.outputs.commit_hash }}\`" >> $GITHUB_STEP_SUMMARY
            if [ "${{ inputs.promotion_target }}" == "stable" ]; then
              echo "**Audit trail:** Commit created in main branch" >> $GITHUB_STEP_SUMMARY
              echo "**flake.lock:** Updated for consumers" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Lightweight promotion:** No flake.lock or audit trail updates" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Consumer repositories will receive this update on their next policy sync." >> $GITHUB_STEP_SUMMARY
          else
            echo "## Promotion Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Reason:** Validation failed" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** \`${{ steps.candidate.outputs.commit_hash }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "See validation results above and check the automatically created issue for next steps." >> $GITHUB_STEP_SUMMARY
          fi