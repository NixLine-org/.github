name: NixLine Promote to Stable (reusable)

on:
  workflow_call:
    inputs:
      promotion_mode:
        description: 'Promotion mode: pr-based or manual'
        required: false
        type: string
        default: 'pr-based'
      commit_hash:
        description: 'Commit hash to promote (for manual mode, defaults to HEAD)'
        required: false
        type: string
      stable_tag:
        description: 'Target stable tag name'
        required: false
        type: string
        default: 'stable'
      promotion_target:
        description: 'Promotion target: stable (full audit trail) or unstable (lightweight)'
        required: false
        type: string
        default: 'stable'

# Note: This workflow requires the following permissions:
# permissions:
#   contents: write
#   actions: write
#   issues: write

jobs:
  promote:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Determine promotion commit
        id: candidate
        run: |
          if [ "${{ inputs.promotion_mode }}" == "manual" ]; then
            # Manual promotion - use provided commit or HEAD
            if [ -n "${{ inputs.commit_hash }}" ]; then
              CANDIDATE_COMMIT="${{ inputs.commit_hash }}"
              echo "Using manual commit: $CANDIDATE_COMMIT"
            else
              CANDIDATE_COMMIT=$(git rev-parse HEAD)
              echo "Using HEAD of main: $CANDIDATE_COMMIT"
            fi
            echo "promotion_type=manual" >> $GITHUB_OUTPUT
          else
            # PR-based promotion - read from .stable-candidate
            if [ -f .stable-candidate ]; then
              CANDIDATE_COMMIT=$(cat .stable-candidate)
              echo "Using PR promotion commit: $CANDIDATE_COMMIT"
              echo "promotion_type=pr" >> $GITHUB_OUTPUT
            else
              echo "found=false" >> $GITHUB_OUTPUT
              echo "Error: .stable-candidate file not found for PR-based promotion"
              exit 1
            fi
          fi

          echo "commit_hash=$CANDIDATE_COMMIT" >> $GITHUB_OUTPUT
          SHORT_HASH="${CANDIDATE_COMMIT:0:12}"
          echo "short_hash=$SHORT_HASH" >> $GITHUB_OUTPUT
          echo "found=true" >> $GITHUB_OUTPUT

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes

      - name: Checkout promotion commit
        run: |
          git checkout ${{ steps.candidate.outputs.commit_hash }}

      - name: Validate flake
        id: validate
        run: |
          echo "## Validating Commit for Promotion" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ steps.candidate.outputs.commit_hash }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          VALIDATION_PASSED=true

          # Run flake check
          echo "### Flake Check" >> $GITHUB_STEP_SUMMARY
          if nix flake check --all-systems --no-build --show-trace; then
            echo "[PASS] Flake check passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "[FAIL] Flake check failed" >> $GITHUB_STEP_SUMMARY
            VALIDATION_PASSED=false
          fi

          # Verify critical apps exist
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### App Verification" >> $GITHUB_STEP_SUMMARY
          for app in sync check create-pack import-policy fetch-license list-licenses; do
            if nix flake show --json | jq -e ".apps.\"x86_64-linux\".\"$app\"" > /dev/null 2>&1; then
              echo "[PASS] **$app**: Available" >> $GITHUB_STEP_SUMMARY
            else
              echo "[FAIL] **$app**: Missing" >> $GITHUB_STEP_SUMMARY
              VALIDATION_PASSED=false
            fi
          done

          # Test key apps
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### App Testing" >> $GITHUB_STEP_SUMMARY

          # Test sync with dry-run (if available)
          if nix run .#sync -- --help > /dev/null 2>&1; then
            echo "[PASS] **sync**: Responsive" >> $GITHUB_STEP_SUMMARY
          else
            echo "[FAIL] **sync**: Not responsive" >> $GITHUB_STEP_SUMMARY
            VALIDATION_PASSED=false
          fi

          # Test list-licenses
          if nix run .#list-licenses > /dev/null 2>&1; then
            echo "[PASS] **list-licenses**: Working" >> $GITHUB_STEP_SUMMARY
          else
            echo "[FAIL] **list-licenses**: Failed" >> $GITHUB_STEP_SUMMARY
            VALIDATION_PASSED=false
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$VALIDATION_PASSED" = "true" ]; then
            echo "### [PASS] Validation Result: PASSED" >> $GITHUB_STEP_SUMMARY
            echo "Commit is ready for promotion to stable." >> $GITHUB_STEP_SUMMARY
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "### [FAIL] Validation Result: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Commit failed validation and cannot be promoted." >> $GITHUB_STEP_SUMMARY
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout current main for audit trail
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'true' && inputs.promotion_target == 'stable'
        run: |
          # Switch back to current main branch to create audit trail
          # This prevents race conditions when main has moved forward
          git checkout main
          git pull origin main

      - name: Update flake.lock and create audit trail
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'true' && inputs.promotion_target == 'stable'
        run: |
          COMMIT=${{ steps.candidate.outputs.commit_hash }}
          SHORT_HASH=${{ steps.candidate.outputs.short_hash }}

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update flake.lock for consumers
          nix flake update

          # Update consumer template flake.lock if it exists
          if [[ -f "templates/consumer/flake.nix" ]]; then
            echo "Updating consumer template flake.lock"
            cd templates/consumer
            nix flake update
            cd ../..
          fi

          # Update .stable-candidate file with promoted commit
          echo "$COMMIT" > .stable-candidate

          # Create audit trail commit
          git add flake.lock .stable-candidate
          # Add consumer template flake.lock if it was updated
          if [[ -f "templates/consumer/flake.lock" ]]; then
            git add templates/consumer/flake.lock
          fi
          git commit -m "Mark $SHORT_HASH as ${{ inputs.promotion_target }} candidate

          Promoted commit: $COMMIT
          Promotion type: ${{ steps.candidate.outputs.promotion_type }}
          Promotion target: ${{ inputs.promotion_target }}
          Validation passed: ${{ steps.validate.outputs.validation_passed }}
          Updated flake.lock for consumers"

          # Push the audit commit to main
          git push origin main

          echo "Created audit trail commit for $COMMIT with updated flake.lock"

      - name: Update promotion tag
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'true'
        run: |
          COMMIT=${{ steps.candidate.outputs.commit_hash }}
          TARGET_TAG="${{ inputs.promotion_target == 'stable' && inputs.stable_tag || inputs.promotion_target }}"

          # Delete local tag if it exists to avoid conflicts
          git tag -d "$TARGET_TAG" 2>/dev/null || true

          # Create new tag at validated commit
          git tag -a "$TARGET_TAG" -m "Promote to ${{ inputs.promotion_target }}: $COMMIT" $COMMIT

          # Force push the tag (safer than remote delete + create)
          git push --force origin "$TARGET_TAG"

          echo "Updated $TARGET_TAG tag to $COMMIT"

      - name: Cleanup marker file
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'true' && steps.candidate.outputs.promotion_type == 'pr'
        uses: actions/github-script@v7
        env:
          SHORT_HASH: ${{ steps.candidate.outputs.short_hash }}
        with:
          script: |
            const shortHash = process.env.SHORT_HASH;

            try {
              // Get the current file to get its SHA
              const file = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.stable-candidate',
                ref: 'main'
              });

              // Delete the file via API
              await github.rest.repos.deleteFile({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.stable-candidate',
                message: 'Remove stable candidate marker after promotion',
                sha: file.data.sha,
                branch: 'main'
              });

              console.log('Removed .stable-candidate from main');
            } catch (error) {
              console.log('Failed to remove .stable-candidate (may not exist): ' + error.message);
            }

            // Delete promotion branch
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/promote-' + shortHash
              });
              console.log('Deleted promotion branch');
            } catch (error) {
              console.log('Failed to delete branch (may not exist): ' + error.message);
            }

      - name: Create validation failure issue
        if: steps.candidate.outputs.found == 'true' && steps.validate.outputs.validation_passed == 'false'
        uses: actions/github-script@v7
        env:
          COMMIT_HASH: ${{ steps.candidate.outputs.commit_hash }}
          SHORT_HASH: ${{ steps.candidate.outputs.short_hash }}
          PROMOTION_TYPE: ${{ steps.candidate.outputs.promotion_type }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const commitHash = process.env.COMMIT_HASH;
            const shortHash = process.env.SHORT_HASH;
            const promotionType = process.env.PROMOTION_TYPE;
            const runUrl = process.env.RUN_URL;

            const title = `Promotion to stable failed for ${shortHash}`;
            const body = `## Promotion Validation Failed\n\n` +
              `The promotion validation failed for commit \`${commitHash}\`.\n\n` +
              `**Promotion type:** ${promotionType}\n` +
              `**Commit:** \`${commitHash}\`\n\n` +
              `### Next Steps\n\n` +
              `1. Review the workflow logs for specific validation errors\n` +
              `2. Fix any identified issues in the codebase\n` +
              `3. Re-run promotion after fixes are committed\n\n` +
              `**Workflow run:** ${runUrl}\n\n` +
              `---\n\n` +
              `*This issue was automatically created by the promotion workflow.*`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['automated', 'promotion-failure', 'validation-error']
            });

      - name: Summary
        if: steps.candidate.outputs.found == 'true'
        run: |
          if [ "${{ steps.validate.outputs.validation_passed }}" == "true" ]; then
            echo "## Promotion Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "${{ steps.candidate.outputs.promotion_type }}" == "manual" ]; then
              echo "**Type:** Manual promotion" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Type:** PR-based promotion" >> $GITHUB_STEP_SUMMARY
            fi

            TARGET_TAG="${{ inputs.promotion_target == 'stable' && inputs.stable_tag || inputs.promotion_target }}"
            echo "**$TARGET_TAG tag updated to:** \`${{ steps.candidate.outputs.commit_hash }}\`" >> $GITHUB_STEP_SUMMARY
            if [ "${{ inputs.promotion_target }}" == "stable" ]; then
              echo "**Audit trail:** Commit created in main branch" >> $GITHUB_STEP_SUMMARY
              echo "**flake.lock:** Updated for consumers" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Lightweight promotion:** No flake.lock or audit trail updates" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Consumer repositories will receive this update on their next policy sync." >> $GITHUB_STEP_SUMMARY
          else
            echo "## Promotion Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Reason:** Validation failed" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** \`${{ steps.candidate.outputs.commit_hash }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "See validation results above and check the automatically created issue for next steps." >> $GITHUB_STEP_SUMMARY
          fi